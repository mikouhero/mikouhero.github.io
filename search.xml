<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[php操作redis常用方法]]></title>
      <url>/2017/10/11/php%E4%B8%8Eredis%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p><strong> php操作redis常用方法：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>——–        redis与php<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">




<h1 id="php操作redis常用方法"><a href="#php操作redis常用方法" class="headerlink" title="php操作redis常用方法"></a>php操作redis常用方法</h1><h2 id="1、connect"><a href="#1、connect" class="headerlink" title="1、connect"></a>1、connect</h2><pre><code>$redis = new redis();  
$result = $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379);  
$redis-&gt;auth(password);                    //如果没有配置密码，则不需这步
</code></pre><h2 id="2、set"><a href="#2、set" class="headerlink" title="2、set"></a>2、set</h2><pre><code>$redis-&gt;set(&apos;test&apos;,&quot;11111111111&quot;);  
</code></pre><h2 id="3、get"><a href="#3、get" class="headerlink" title="3、get"></a>3、get</h2><pre><code>$result = $redis-&gt;get(&apos;test&apos;);  
</code></pre><h2 id="4、delete"><a href="#4、delete" class="headerlink" title="4、delete"></a>4、delete</h2><pre><code>描述：删除指定的键
参数：一个键，或不确定数目的参数，每一个关键的数组：key1 key2 key3 … keyN
$redis-&gt;delete(&apos;test&apos;);  
</code></pre><h2 id="5、setnx"><a href="#5、setnx" class="headerlink" title="5、setnx"></a>5、setnx</h2><pre><code>描述：如果在数据库中不存在该键，设置关键值参数
参数：key value
$redis-&gt;set(&apos;test&apos;,&quot;1111111111111&quot;);  
$redis-&gt;setnx(&apos;test&apos;,&quot;22222222&quot;);  
echo $redis-&gt;get(&apos;test&apos;);  //结果：1111111111111  
</code></pre><h2 id="6、exists"><a href="#6、exists" class="headerlink" title="6、exists"></a>6、exists</h2><pre><code>描述：验证指定的键是否存在
参数key
$redis-&gt;set(&apos;test&apos;,&quot;1111111111111&quot;);  
var_dump($redis-&gt;exists(&apos;test&apos;));  //结果：bool(true)  
</code></pre><h2 id="7-incr"><a href="#7-incr" class="headerlink" title="7 incr"></a>7 incr</h2><pre><code>描述：数字递增存储键值键.
参数：key value：将被添加到键的值
$redis-&gt;set(&apos;test&apos;,&quot;123&quot;);  
var_dump($redis-&gt;incr(&quot;test&quot;));  //结果：int(124) 
</code></pre><h2 id="8、decr"><a href="#8、decr" class="headerlink" title="8、decr"></a>8、decr</h2><pre><code>描述：数字递减存储键值。
参数：key value：将被添加到键的值 
$redis-&gt;set(&apos;test&apos;,&quot;123&quot;);  
var_dump($redis-&gt;decr(&quot;test&quot;));  //结果：int(122)     
</code></pre><h2 id="9、getMultiple"><a href="#9、getMultiple" class="headerlink" title="9、getMultiple"></a>9、getMultiple</h2><pre><code>描述：取得所有指定键的值。如果一个或多个键不存在，该数组中该键的值为假
参数：其中包含键值的列表数组
$result = $redis-&gt;getMultiple(array(&apos;test1&apos;,&apos;test2&apos;));
</code></pre><h2 id="10、lpush"><a href="#10、lpush" class="headerlink" title="10、lpush"></a>10、lpush</h2><pre><code>描述：由列表头部添加字符串值。如果不存在该键则创建该列表。如果该键存在，而且不是一个列表，返回FALSE。
参数：key,value
var_dump($redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;));   //结果：int(1)  
</code></pre><h2 id="11，rpush"><a href="#11，rpush" class="headerlink" title="11，rpush"></a>11，rpush</h2><pre><code>描述：由列表尾部添加字符串值。如果不存在该键则创建该列表。如果该键存在，而且不是一个列表，返回FALSE。
参数：key,value
var_dump($redis-&gt;lpush(&quot;test&quot;,&quot;111&quot;));   //结果：int(1)  
</code></pre><h2 id="12、lpop"><a href="#12、lpop" class="headerlink" title="12、lpop"></a>12、lpop</h2><pre><code>描述：返回和移除列表的第一个元素
参数：key
var_dump($redis-&gt;lpop(&quot;test&quot;));  //结果：string(3) &quot;222&quot;  
</code></pre><h2 id="13，lsize-llen"><a href="#13，lsize-llen" class="headerlink" title="13，lsize,llen"></a>13，lsize,llen</h2><pre><code>描述：返回的列表的长度。如果列表不存在或为空，该命令返回0。如果该键不是列表，该命令返回FALSE。
参数：Key
$redis-&gt;lsize(&quot;test&quot;);
</code></pre><h2 id="14、lget"><a href="#14、lget" class="headerlink" title="14、lget"></a>14、lget</h2><pre><code>描述：返回指定键存储在列表中指定的元素。 0第一个元素，1第二个… -1最后一个元素，-2的倒数第二…
     错误的索引或键不指向列表则返回FALSE。
参数：key index
($redis-&gt;lget(&quot;test&quot;,3));
</code></pre><h2 id="15、lset"><a href="#15、lset" class="headerlink" title="15、lset"></a>15、lset</h2><pre><code>描述：为列表指定的索引赋新的值,若不存在该索引返回false.
参数：key index value
var_dump($redis-&gt;lget(&quot;test&quot;,1));  //结果：string(3) &quot;111&quot;  
var_dump($redis-&gt;lset(&quot;test&quot;,1,&quot;333&quot;));  //结果：bool(true)
</code></pre><h2 id="16、lgetrange"><a href="#16、lgetrange" class="headerlink" title="16、lgetrange"></a>16、lgetrange</h2><pre><code>描述：返回在该区域中的指定键列表中开始到结束存储的指定元素，lGetRange(key, start, end)。
     0第一个元素，1第二个元素… -1最后一个元素，-2的倒数第二…
参数：key start end
print_r($redis-&gt;lgetrange(&quot;test&quot;,0,-1));  //结果：Array ( [0] =&gt; 222 [1] =&gt; 111 )
</code></pre><h2 id="17、lremove"><a href="#17、lremove" class="headerlink" title="17、lremove"></a>17、lremove</h2><pre><code>描述：从列表中从头部开始移除count个匹配的值。如果count为零，所有匹配的元素都被删除。
     如果count是负数，内容从尾部开始删除。
参数：key  value count
($redis-&gt;lremove(&apos;test&apos;,&apos;a&apos;,2));
</code></pre><h2 id="18、sadd"><a href="#18、sadd" class="headerlink" title="18、sadd"></a>18、sadd</h2><pre><code>描述：为一个Key添加一个值。如果这个值已经在这个Key中，则返回FALSE。
参数：key value
var_dump($redis-&gt;sadd(&apos;test&apos;,&apos;111&apos;));   //结果：bool(true)  
</code></pre><h2 id="19、sremove"><a href="#19、sremove" class="headerlink" title="19、sremove"></a>19、sremove</h2><pre><code>描述：删除Key中指定的value值
参数：key member
redis-&gt;sremove(&apos;test&apos;,&apos;111&apos;);  
</code></pre><h2 id="20、smove"><a href="#20、smove" class="headerlink" title="20、smove"></a>20、smove</h2><pre><code>描述：将Key1中的value移动到Key2中
参数：srcKey dstKey member
$redis-&gt;smove(&apos;test&apos;,&quot;test1&quot;,&apos;111&apos;);  
</code></pre><h2 id="21，scontains"><a href="#21，scontains" class="headerlink" title="21，scontains"></a>21，scontains</h2><pre><code>描述：检查集合中是否存在指定的值。
参数：key value
($redis-&gt;scontains(&apos;test&apos;, &apos;111&apos;));
</code></pre><h2 id="22、ssize"><a href="#22、ssize" class="headerlink" title="22、ssize"></a>22、ssize</h2><pre><code>描述：返回集合中存储值的数量
参数：key
echo $redis-&gt;ssize(&apos;test&apos;);  
</code></pre><h2 id="23、spop"><a href="#23、spop" class="headerlink" title="23、spop"></a>23、spop</h2><pre><code>描述：随机移除并返回key中的一个值
参数：key
$redis-&gt;spop(&quot;test&quot;)
</code></pre><h2 id="24、sinter"><a href="#24、sinter" class="headerlink" title="24、sinter"></a>24、sinter</h2><pre><code>描述：返回一个所有指定键的交集。如果只指定一个键，那么这个命令生成这个集合的成员。如果不存在某个键，则返回FALSE。
参数：key1, key2, keyN
$redis-&gt;sinter(&quot;test&quot;,&quot;test1&quot;)
</code></pre><h2 id="25、sinterstore"><a href="#25、sinterstore" class="headerlink" title="25、sinterstore"></a>25、sinterstore</h2><pre><code>描述：执行sInter命令并把结果储存到新建的变量中。
参数：
Key: dstkey, the key to store the diff into.
Keys: key1, key2… keyN. key1..keyN are intersected as in sInter.
$redis-&gt;sinterstore(&apos;new&apos;,&quot;test&quot;,&quot;test1&quot;)
</code></pre><h2 id="26、sunsion"><a href="#26、sunsion" class="headerlink" title="26、sunsion"></a>26、sunsion</h2><pre><code>描述：
返回一个所有指定键的并集
参数：
Keys: key1, key2, … , keyN
$redis-&gt;sunion(&quot;test&quot;,&quot;test1&quot;))
</code></pre><h2 id="27-sunionstore"><a href="#27-sunionstore" class="headerlink" title="27,sunionstore"></a>27,sunionstore</h2><pre><code>描述：执行sunion命令并把结果储存到新建的变量中。
参数：
Key: dstkey, the key to store the diff into.
Keys: key1, key2… keyN. key1..keyN are intersected as in sInter.
</code></pre><h2 id="28、sdiff"><a href="#28、sdiff" class="headerlink" title="28、sdiff"></a>28、sdiff</h2><pre><code>描述：返回第一个集合中存在并在其他所有集合中不存在的结果
参数：Keys: key1, key2, … , keyN: Any number of keys corresponding to sets in redis.
$redis-&gt;sdiff(&quot;test&quot;,&quot;test1&quot;));  //结果：Array ( [0] =&gt; 222 [1] =&gt; 333 )  
</code></pre><h2 id="29、sdiffstore"><a href="#29、sdiffstore" class="headerlink" title="29、sdiffstore"></a>29、sdiffstore</h2><pre><code>描述：执行sdiff命令并把结果储存到新建的变量中。
参数：
Key: dstkey, the key to store the diff into.
Keys: key1, key2, … , keyN: Any number of keys corresponding to sets in redis
($redis-&gt;smembers(&apos;new&apos;)
</code></pre><h2 id="30、smembers-sgetmembers"><a href="#30、smembers-sgetmembers" class="headerlink" title="30、smembers, sgetmembers"></a>30、smembers, sgetmembers</h2><pre><code>描述：返回集合的内容
参数：Key: key
$redis-&gt;smembers(&apos;test&apos;));  //结果:Array ( [0] =&gt; 111 [1] =&gt; 222 ）
</code></pre></the>]]></content>
      
        
        <tags>
            
            <tag> php </tag>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis简介]]></title>
      <url>/2017/10/11/redis%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p><strong> Redis简介：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>——–        简介<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">


<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><pre><code>1、redis支持数据的持久化,可以将内存中的数据保存在磁盘中，重启的时候可以再次加重进行使用
2、redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
3、redis支持数据的备份，即master-slave模式的数据备份。 
</code></pre><h2 id="redis优势"><a href="#redis优势" class="headerlink" title="redis优势"></a>redis优势</h2><pre><code>1、性能极高-redis能读的速度是110000次/s,写的速度是81000次/s 
2、丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
3、原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。
   单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。
4、丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。
</code></pre><h2 id="redis的数据类型"><a href="#redis的数据类型" class="headerlink" title="redis的数据类型"></a>redis的数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><pre><code>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。

string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。

string类型是Redis最基本的数据类型，一个键最大能存储512MB。
</code></pre><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><pre><code>hash 是一个键值对集合，一个string类型的field和value的映射表，hash特别适合用于存储对象。
</code></pre><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><pre><code>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）
</code></pre><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><pre><code>Redis的Set是string类型的无序集合。

集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。
</code></pre><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><pre><code>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。

不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。

zset的成员是唯一的,但分数(score)却可以重复。
</code></pre></the>]]></content>
      
        
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL主从配置]]></title>
      <url>/2017/10/10/MySQL%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p><strong> MySQL主从配置：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>——–        主从配置<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">


<h1 id="MySQL主从配置"><a href="#MySQL主从配置" class="headerlink" title="MySQL主从配置"></a>MySQL主从配置</h1><blockquote>
<p>mysql复制的优点</p>
</blockquote>
<pre><code>1、如果主服务器出现问题，可以快速切换到从服务器上提供服务
2、可以在从服务器上执行查询操作，降低主服务器的访问压力
3、可以在从服务器上执行备份，以避免备份期间影响主服务器的服务

一般只有更新不频繁的数据或者对实时性要求不高的数据可以通过从服务器查询，实时性要求高的数据仍然需要在主服务器数据库获得
</code></pre><blockquote>
<p>注意：如果是LNMP环境需要关闭防火墙，MySQL5.6的虚拟机为克隆需要删除在库目录中的auto.cnf文件，否则无法主从复制。</p>
</blockquote>
<h3 id="主服务器配置"><a href="#主服务器配置" class="headerlink" title="主服务器配置"></a>主服务器配置</h3><pre><code>1.授权一个用户，在从服务器上可以通过这个用户来连接主服务器

    mysql&gt; grant replication slave on *.* to repl@从服务器ip  indentified by &apos;密码&apos;;
            select user,host,password from mysql.user;

2、修改主数据库服务器的配置文件

    vi /etc/my.cnf    
    [mysql]    
    log-bin=mysql-bin
    server-id = 1
    binlog-do-db =         #可以被记录binlog的库
    binlog-ingnore-db =    #忽略记录binlog的库

3、主服务器清空所有的bin-log日志

    mysql&gt; reset master;
           show master status;

4、备份主数据库的数据
    cd /usr/local/mysql/bin/
    ./mysqldump -uroot -p test -l -F &gt;&apos;/tmp/test.sql&apos;;
</code></pre><h3 id="从服务器配置"><a href="#从服务器配置" class="headerlink" title="从服务器配置"></a>从服务器配置</h3><pre><code>1、把主服务器上的备份文件，拷贝到从服务器上
    scp root@主服务器ip:/tmp/test.sql  /tmp/test.sql

2、把北峰文件，恢复到数据库
    mysql -uroot -p test -f &lt; &apos;/tmp/test.sql&apos;

3、清空所有bin-log
    mysql&gt; reset master ; 主从服务器都清空

4、修改配置文件
    vi  /etc/my.cnf
    [mysqld]
    log-bin = mysql-bin         #已存在不需要修改
    server-id = 2            #修改
    replcate--do-db = test  #新增，要复制同步的数据库

以下根据需要添加
    log_slave_updates  = 1  # 将同步数据写入binlog日志
    read_only  = 1            #限制用户写写入数据（普通用户、root等全部权限用户无法限制）
    replicate-ignore-db = mysql  #新增，要忽略同步的数据库
    replicate-do-table = #新增，要复制同步的数据表
    replicate-ignore-table = #新增，要忽略同步的数据库

注意 server-id 要唯一，如果前面已经开启或设置，不需要重复设置

5、重启从数据库服务
    pkill mysql;
    /usr/local/mysql/bin/mysqld_safe --user=mysql &amp;;
    或者 service mysql restart

6、从服务器进入mysql命令行
    ./mysql -uroot -p
    stop slave;

    change master to 
    master_host = &apos;主服务器ip&apos;,
    master_user = &apos;&apos;,
    master_password = &apos;&apos;;

查看是否成功
show slave status \G

Connect_Retry: 60                 如果失败，每60秒尝试一次

Master_Log_File: mysql-bin.000002 主服务器的bin-log日志文件

Read_Master_Log_Pos: 107          对应的位置

Slave_IO_Running: Yes             从主服务器上读取binlog日志，并写入从服务器上的中继日志中

Slave_SQL_Running: Yes            读取并且执行中继日志中的binlog日志
#注：以上两个都为yes则表明成功，只要其中一个进程的状态是no，则表示复制进程停止，错误原因可以从&quot;last_error&quot;字段的值中看到.

从服务器只建议做读操作，主服务器无法同步从服务器的写操作。
完成！！！可测试查看同步情况

show processlist \G

如果主服务器在使用中，可以锁定数据库禁止写入，配置好后在解锁
flush tables with read lock;
unlock tables;
</code></pre><h3 id="数据库常用命令"><a href="#数据库常用命令" class="headerlink" title="数据库常用命令"></a>数据库常用命令</h3><pre><code>1、    启动复制线程
    start slave     

2、    停止复制线程
    stop slave

3、查看从数据库状态
    show slave status

4、查看主数据库的bin-log 日志
    show master logs;

5、动态改变到主服务器的配置
    change master to 

6、查看从数据库运行进程
    show processlist
</code></pre><h1 id="双主"><a href="#双主" class="headerlink" title="双主"></a>双主</h1><h2 id="将复制事件写入binlog"><a href="#将复制事件写入binlog" class="headerlink" title="将复制事件写入binlog"></a>将复制事件写入binlog</h2><pre><code>log-slave-updates = trues #一台服务器既做主库又做从库此选项必须要开启
</code></pre><h2 id="masterA自增长ID"><a href="#masterA自增长ID" class="headerlink" title="masterA自增长ID"></a>masterA自增长ID</h2><pre><code>auto_increment_offset = 1;
auto_increment_increment = 2;    #奇数id
</code></pre><h2 id="masterB自增长ID"><a href="#masterB自增长ID" class="headerlink" title="masterB自增长ID"></a>masterB自增长ID</h2><pre><code>auto_increment_offset = 2;
auto_increment_increment = 2;    #偶数id
</code></pre></the>]]></content>
      
        
        <tags>
            
            <tag> 主从配置 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL授权]]></title>
      <url>/2017/10/10/MySQL%E6%8E%88%E6%9D%83/</url>
      <content type="html"><![CDATA[<p><strong> MySQL授权：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>——–        授权<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">



<h1 id="MySQL授权"><a href="#MySQL授权" class="headerlink" title="MySQL授权"></a>MySQL授权</h1><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><pre><code>两台linux lamp环境搭建完毕
主服务器(master)      ip1
从服务器(slave)        ip2
</code></pre><blockquote>
<p>主服务器master上的操作</p>
</blockquote>
<pre><code>mysql&gt;select user,host,password from mysql.user;
</code></pre><p>root用户，只能在本机master登录，下面试验看能否从其它电脑</p>
<blockquote>
<p>从服务器（slave）上操作    </p>
</blockquote>
<pre><code>mysql -ujack -p -hip1;
登录被拒绝，需要授权身份
</code></pre><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><blockquote>
<p>主服务器master上的操作</p>
</blockquote>
<pre><code>mysql&gt; grant all on *.* to jack@ip2 identified by &quot;密码&quot;;
</code></pre><blockquote>
<p>从服务器（slave）上操作    </p>
</blockquote>
<pre><code>mysql -ujack -p -hip1;
登录成功
</code></pre><blockquote>
<p>详细信息</p>
</blockquote>
<pre><code>all        权限，超级管理员(除了grant和revoke)
*.*        范围某个数据库的某个表
jack     用户名
ip2        登录源地址，可用‘%’局部和全局匹配
</code></pre></the>]]></content>
      
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 授权 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL日志恢复数据]]></title>
      <url>/2017/10/10/MySQL%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p><strong> MySQL日志恢复数据：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>——–        恢复数据<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">



<h1 id="big-log-日志"><a href="#big-log-日志" class="headerlink" title="big-log 日志"></a>big-log 日志</h1><blockquote>
<p>big-log:记录数据库写操作的二进制日志文件，服务重启或备份时可生成新的日志文件</p>
</blockquote>
<h2 id="big-log日志基础"><a href="#big-log日志基础" class="headerlink" title="big-log日志基础"></a>big-log日志基础</h2><p>1、开启（默认状态）<br>        vi /etc/my.cnf<br>        [mysqld]<br>        log-bin = mysql-bin</p>
<pre><code>ls /usr/local/mysql/data/
mysql-bin.000001
mysql-bin.000002
...
//记录了所有的数据库变化的操作（数据库的增删改，创建表等）
</code></pre><p>2、相关SQL:查看是否开启</p>
<pre><code>mysql&gt;show variables like &quot;%log%&quot;;
log_bin   | ON        //表示开启
</code></pre><p>3、相关SQL:bin-log日志的刷新</p>
<pre><code>mysql&gt;flush lods; 
//开始一个新的bin-log日志，记录此刻以后的操作
</code></pre><p>4、相关SQL:查看当前使用的bin-log信息</p>
<pre><code>mysql&gt;show master status;
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000008 | 107      |              |                  |
+------------------+----------+--------------+-----------------
</code></pre><p>5、相关SQL:清空所有的bin-log日志</p>
<pre><code>mysql&gt; reset master;
</code></pre><p>6、查看bin-log日志内容</p>
<pre><code>cd /usr/local/mysql/data/
/usr/local/mysql/bin/mysqlbinlog mysql-bin.0000001
</code></pre><p>7、bin-log日志使用测试</p>
<pre><code>use test;
reset master; //清空所有的bin-log日志
show master status;//当前的file是mysql-bin.000001当前位置position 是 107
create table users (id int,name varchar(50)); //此时show master status发现位置Position已改变为214
insert into users (id,name) values (1,&apos;admin&apos;);//此时show master status发现位置Position已改变为418
insert into users (id,name) values (2,&apos;guest&apos;);//此时show master status发现位置Position已改变为622

cd /usr/local/mysql/data
/usr/local/mysql/bin/mysqlbinlog mysql-bin.000001

bin-log日志完整记录着每一个position位置执行了什么sql语句，可以用来恢复数据里面的语句，可以直接拿到命令行执行

将此时的mysql-bin.000001文件保留下来，开启一个新的日志文件
flush logs;
show master status;

文件file切换到mysql-bin.000002. 在这以后操作数据库，日志将记录到新的文件文件中。

此时删除了数据表users 
drop table users

通过刚才的mysql-bin.000001恢复数据
cd  /usr/local/mysql/data
/usr/local/mysql/bin/mysqlbinlog mysql-bin.000001 | /usr/local/mysql/bin/mysql -uroot -p

相当于吧之前执行过的sql语句（在mysql-bin.000001），在执行一次，而mysql-bin.000002中记录的删除操作没有执行
</code></pre><h2 id="完整的备份及恢复实例"><a href="#完整的备份及恢复实例" class="headerlink" title="完整的备份及恢复实例"></a>完整的备份及恢复实例</h2><p>1、操作数据库前做一个完整备份</p>
<pre><code>cd /usr/local/mysql/bin/ 
mysqldump -uroot -p -l -F test&gt;&apos;/tmp/test日期格式.sql&apos;
备份test数据库到 /tmp/
-l 备份时加锁，在整个备份期间，只允许读操作，不允许写操作
-F 即flush logs,可以重新生成新的日志文件，当然包括log-bin日志
</code></pre><p>2、查看binlog日志</p>
<pre><code>mysql&gt;show master status;
产生新的bin-log文件mysql-bin.000003
完整备份完成以后，所有对数据库的操作，将会记录到这个新的bin-log文件中
</code></pre><p>3、开始操作数据库</p>
<pre><code>insert into users values (3,&apos;jack&apos;);
update users set name=&apos;mary&apos; where id=2;
</code></pre><p>4、出现误删,所有数据清空</p>
<pre><code>delete from users;
</code></pre><p>5 准备恢复，开始一个新的bin-log日志（目的是保留mysql-bin.000003的现状）</p>
<pre><code>flush logs;
</code></pre><p>6、先恢复到之前的完整备份文件 mysq -uroot -p test -f &lt;’备份文件的路径’</p>
<p>7、接着恢复后面的操作,需要从bin-log日志中恢复</p>
<p>8、查看mysql-bin.000003日志文件</p>
<pre><code>cd /usr/local/mysql/data
/usr/local/mysql/bin/mysqlbinlog mysql-bin.000003|more
查找误删除的位置
发现在565位置，是误操
# at 565
#140821 8:33:14 server id 2 end_log_pos 645 Query thread_id=18 exec_time=0 error_code=0
SET TIMESTAMP=1408581194/*!*/;
delete from user....

要恢复执行的操作将107行开始，在565行停止，mysql-bin.000003文件不能全部执行！！！

/usr/local/mysql/bin/mysqlbinlog mysql-bin.000003 --start-position=&quot;107&quot; --stop-position=&quot;565&quot; | mysql -uroot –p
</code></pre><h2 id="常用还原选项"><a href="#常用还原选项" class="headerlink" title="常用还原选项"></a>常用还原选项</h2><p>1、按位置</p>
<pre><code>--start-position  --stop-position
</code></pre><p>2、按时间</p>
<pre><code>--start-data --stop-data
eg：--start-date=&quot;2010-09-29 18:00:00&quot; --stop-date=&quot;2010-09-29 23:00:00&quot;
</code></pre><p>3、按库名</p>
<pre><code>-d
eg：  -d test #只备份test数
</code></pre></the>]]></content>
      
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 恢复数据 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL常用操作]]></title>
      <url>/2017/10/10/MySQL%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p><strong> MySQL常用操作：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>——–        常用操作<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">



<h1 id="MySQL常用操作"><a href="#MySQL常用操作" class="headerlink" title="MySQL常用操作"></a>MySQL常用操作</h1><h2 id="1-表复制"><a href="#1-表复制" class="headerlink" title="1.     表复制"></a>1.     表复制</h2><blockquote>
<p>复制表结构+复制表数据（推荐）</p>
</blockquote>
<pre><code>create table t2 like t1;
insert into t2 select * from t1;
</code></pre><blockquote>
<p>直接复制表数据，但无索引和约束</p>
</blockquote>
<pre><code>create table t3 select * from t1; 
</code></pre><h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2.    函数"></a>2.    函数</h2><blockquote>
<p>数学</p>
</blockquote>
<pre><code>ABS(x)                       返回x的绝对值
BIN(x)                       返回x的二进制（OCT返回八进制，HEX返回十六进制）
CEILING(x)                   返回大于x的最小整数值
FLOOR(x)                       返回小于x的最大整数值
GREATEST(x1,x2,...,xn)        返回集合中最大的值
LEAST(x1,x2,...,xn)          返回集合中最小的值
LN(x)                        返回x的自然对数
LOG(x,y)                    返回x的以y为底的对数
MOD(x,y)                     返回x/y的模（余数）
PI()                        返回pi的值（圆周率）
RAND()                        返回０到１（不含1）的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。
ROUND(x,y)                    返回参数x的四舍五入的有y位小数的值
SIGN(x)                     返回代表数字x的符号的值
SQRT(x)                     返回一个数的平方根
TRUNCATE(x,y)                返回数字x截短为y位小数的结果
</code></pre><blockquote>
<p>聚合(常用于GROUP BY从句的SELECT查询中)</p>
</blockquote>
<pre><code>AVG(col)                    返回指定列的平均值
COUNT(col)                    返回指定列中非NULL值的个数
MIN(col)                    返回指定列的最小值
MAX(col)                    返回指定列的最大值
SUM(col)                    返回指定列的所有值之和
GROUP_CONCAT(col)             返回由属于一组的列值连接组合而成的结果
</code></pre><blockquote>
<p>字符串函数</p>
</blockquote>
<pre><code>ASCII(char)                    返回字符的ASCII码值
BIT_LENGTH(str)                返回字符串的比特长度
CONCAT(s1,s2...,sn)            将s1,s2...,sn连接成字符串
CONCAT_WS(sep,s1,s2...,sn)    将s1,s2...,sn连接成字符串，并用sep字符间隔
LCASE(str)或LOWER(str)        返回将字符串str中所有字符改变为小写后的结果
LEFT(str,x)                    返回字符串str中最左边的x个字符
LENGTH(s)                    返回字符串str中的字符数
LTRIM(str)                     从字符串str中切掉开头的空格
POSITION(substr,str)        返回子串substr在字符串str中第一次出现的位置
REPEAT(str,srchstr,rplcstr)    返回字符串str重复x次的结果
REVERSE(str)                 返回颠倒字符串str的结果
RIGHT(str,x)                 返回字符串str中最右边的x个字符
RTRIM(str)                     返回字符串str尾部的空格
TRIM(str)                    去除字符串首部和尾部的所有空格
UCASE(str)或UPPER(str)         返回将字符串str中所有字符转变为大写后的结果
</code></pre><blockquote>
<p>日期和时间函数</p>
</blockquote>
<pre><code>CURDATE()或CURRENT_DATE()     返回当前的日期
CURTIME()或CURRENT_TIME()     返回当前的时间
DATE_FORMAT(date,fmt)          依照指定的fmt格式格式化日期date值
FROM_UNIXTIME(ts,fmt)          根据指定的fmt格式，格式化UNIX时间戳ts
HOUR(time)                   返回time的小时值(0~23)
MINUTE(time)                   返回time的分钟值(0~59)
MONTH(date)                   返回date的月份值(1~12)
NOW()                        返回当前的日期和时间
WEEK(date)                   返回日期date为一年中第几周(0~53)
YEAR(date)                   返回日期date的年份(1000~9999)    
</code></pre><blockquote>
<p>加密函数</p>
</blockquote>
<pre><code>MD5(str)                    计算字符串str的MD5校验和
PASSWORD(str)               返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法。
SHA(str)                    计算字符串str的安全散列算法(SHA)校验和
</code></pre><blockquote>
<p>格式化函数</p>
</blockquote>
<pre><code>FORMAT(x,y)                   把x格式化为以逗号隔开的数字序列，y是结果的小数位数
INET_ATON(ip)               返回IP地址的数字表示
INET_NTOA(num)               返回数字所代表的IP地址
</code></pre><blockquote>
<p>系统信息函数</p>
</blockquote>
<pre><code>DATABASE()                   返回当前数据库名
BENCHMARK(count,expr)          将表达式expr重复运行count次
CONNECTION_ID()               返回当前客户的连接ID
FOUND_ROWS()                   返回最后一个SELECT查询进行检索的总行数
USER()或SYSTEM_USER()          返回当前登陆用户名
VERSION()                   返回MySQL服务器的版本
</code></pre><blockquote>
<p>以上函数全部使用select调用输出，以下为常用show操作</p>
</blockquote>
<pre><code>SHOW CHARACTER SET            显示所有可用的字符集
SHOW COLLATION                输出包括所有可用的校对字符集
SHOW COLUMNS                显示在一个给定表中的各列的信息,对于视图，本语句也起作用。
SHOW CREATE DATABASE        显示用于创建给定数据库CREATE DATABASE语句。
SHOW DATABASES                SHOW DATABASES可以在MySQL服务器主机上列举数据库。
SHOW ENGINES                检查一个存储引擎是否被支持，或者对于查看默认引擎是什么
SHOW INDEX                    会返回表索引信息。
SHOW TABLES                    列举了给定数据库中的非TEMPORARY表。    
SHOW VARIABLES                列举当前环境变量
</code></pre><h2 id="3-预处理"><a href="#3-预处理" class="headerlink" title="3. 预处理"></a>3. 预处理</h2><blockquote>
<p>预先处理SQL的语法，通过传值完成SQL。</p>
<p>优势：提高效率（重用），防止SQL注入（安全）。<br>PDO中的prepare就是调用该方法！！！</p>
</blockquote>
<pre><code>1、设置stmt1预处理，传递一个数据作为一个where判断条件
       prepare stmt1 from &apos;select * from t1 where id&gt;?&apos;;
2、设置一个变量
       set @i=1;
3、执行stmt1预处理
       execute stmt1 using @i;
4、删除预处理
       drop prepare stmt1;
</code></pre><h2 id="4-事务"><a href="#4-事务" class="headerlink" title="4.    事务"></a>4.    事务</h2><blockquote>
<p>多个步骤为一个过程的事物（整体）,中间有任何一个环节出问题，都会造成事物的回滚</p>
<p>表类型（引擎）：innodb</p>
</blockquote>
<pre><code>1、    关闭自动提交功能或开启事务
    set autocommit=0;
    begin;
2、    删除记录
    delete from t1 where id = 2;
3、    创建还原点
    savepoint p1;
4、    删除记录
    delete from t1 where id = 3;
5、    再创建还原点
    savepoint p2;
6、    删除记录
    delete from t1 where id = 4;
7   退回还原点
    rollback to p1;
    rollback to p2;
8    退回起始点
    rollback;
9   确认提交
    commit;
</code></pre><h2 id="5-存储"><a href="#5-存储" class="headerlink" title="5.    存储"></a>5.    存储</h2><blockquote>
<p>批量的有规律的mysql操作可以事前存在procedure中，后期调用。</p>
</blockquote>
<pre><code>1、    创建一个存储p1()
    \d //        //将结束符修改为”//”  或者delimiter //
    create procedure p1()
    -&gt;begin
    -&gt;set @i=1;
    -&gt;while @i&lt;6 do
    -&gt; select * from t1 where id=@i;
    -&gt;set @i=@i+1;
    -&gt;end while;
    -&gt;end//
2、    执行存储p1()
    \d ;            //将结束符修改回；
    call p1;
3、    查看所有procedure的status信息
    show procedure status\G
4、    查看procddure p1()的具体信息
    show create procedure p1\G
5、    删除procedure
    drop procedure p1;
</code></pre><h2 id="6-触发器"><a href="#6-触发器" class="headerlink" title="6.    触发器"></a>6.    触发器</h2><blockquote>
<p>监视某种事件，并触发某种操作。（商品添加，订单消除等连贯表操作时使用）</p>
<p>触发四要素：</p>
<p>1、监视地点（table）2、触发时间（after/before）3、监视事件（insert/update/delete）4、触发事件（insert/update/delete）</p>
</blockquote>
<pre><code>1、    修改delimiter为//
    \d //
2、    创建一个名为tg1的触发器，当向t1表中插入数据前，就向a表中插入一条数据
    create trigger tg1 before insert on t1 for each row    #固定写法
    -&gt;begin
    -&gt; insert into a values (4);
    -&gt;end//
3、    修改delimiter为;
    \d ;
4、    插入数据测试
    insert into t1 values (null,&apos;tom&apos;);
</code></pre><h2 id="7-视图"><a href="#7-视图" class="headerlink" title="7.    视图"></a>7.    视图</h2><pre><code>    insert into t1 (name) select t1.name from t1;
创建视图：
       create view v_t1 as select * from t1 where id&gt;1 and id&lt;5;
视图帮助信息：
       ?  view
    ALTER VIEW
    CREATE VIEW
    DROP VIEW    
查看视图：
    show tables;
    select * from v_t1;
删除视图：
    drop view v_t1;
    视图相当于表查询的快捷方式，表数据改变，视图也跟着变。
</code></pre><h2 id="8-临时表"><a href="#8-临时表" class="headerlink" title="8.    临时表"></a>8.    临时表</h2><blockquote>
<p>仅在当前session有效的存在于内存中的临时表。</p>
</blockquote>
<pre><code>create temporary table tmp1 (id int) ;
</code></pre><blockquote>
<p>只对当前会话(连接)有效，断开后，临时表自动清除，也可以自己drop table tmp1;临时表在销毁前，文件暂存/tmp下。</p>
</blockquote>
<h2 id="9-虚拟表-dual"><a href="#9-虚拟表-dual" class="headerlink" title="9.    虚拟表 dual"></a>9.    虚拟表 dual</h2><blockquote>
<p>在Oracl中有虚拟表技术，MySQL也效仿设置虚拟表。MySQL中直接查数据或者调用函数可以不用from表，但为了照顾select from 的习惯固设立虚拟表 <strong>dual</strong></p>
</blockquote>
<pre><code>select now();        //实际操作为下句
select now() from dual;
</code></pre><h2 id="10-重置自增"><a href="#10-重置自增" class="headerlink" title="10.    重置自增"></a>10.    重置自增</h2><blockquote>
<p>MySQL数据库自增ID如何恢复</p>
</blockquote>
<pre><code>清空表
    delete    from  tablename            //只能清空数据，不能重置ID
修改表
    alter table tablename auto_increment=1;    
或者
    truncate    table tablename;    //推荐
</code></pre><h2 id="11-数据导入导出"><a href="#11-数据导入导出" class="headerlink" title="11.    数据导入导出"></a>11.    数据导入导出</h2><blockquote>
<p>完整备份：</p>
</blockquote>
<pre><code>/usr/local/mysql/bin/mysqldump -uroot -p -l -F test&gt;&apos;/tmp/test.sql&apos;
</code></pre><blockquote>
<p>导出一个数据库中每一个表的相关SQL语句，包含建表、增删改查等导入导出速度慢！</p>
<p>完整导入：</p>
</blockquote>
<pre><code>create database test2;

/usr/local/mysql/bin//mysql -uroot -p123 test2&lt;/tmp/test.sql
</code></pre><blockquote>
<p>单表数据备份：</p>
</blockquote>
<pre><code>select * from t1 into outfile &apos;/tmp/t1.txt&apos;;
</code></pre><blockquote>
<p>仅仅是导出表数据，查什么就导出什么。</p>
<p>导入数据：</p>
</blockquote>
<pre><code>truncate t1;        #准备工作，先清空表，或自己创建一个表    
    load data infile &apos;/tmp/t1.txt&apos; into table t1;

可以指定某一些列，空置字段为NULL或者默认值
    load data infile &apos;/test/users.txt&apos; into table users(id,name);
</code></pre><h2 id="12-索引操作"><a href="#12-索引操作" class="headerlink" title="12. 索引操作"></a>12. 索引操作</h2><blockquote>
<p>什么是索引？<br>就像是书的目录，能够提高查询速度，降低写入速度，占用磁盘空间</p>
<p>分类：主键、唯一、普通、全文(sphinx等检索引擎代替)</p>
</blockquote>
<pre><code>ALTER TABLE ADD                //增
ALTER TABLE table_name ADD INDEX idx_name(column_list)
ALTER TABLE table_name ADD UNIQUE uk_name (column_list)
ALTER TABLE table_name ADD PRIMARY KEY (column_list)
ALTER TABLE DROP            //删
ALTER TABLE table_name DROP INDEX idx_name/uk_name    //唯一和普通都用此方式
ALTER TABLE table_name DROP PRIMARY KEY
show index from table_name    //查
</code></pre><blockquote>
<p>注意：</p>
<p>删除主键索引，该字段不能有auto_increment，如果有先修改掉再删。</p>
<p>修改索引：先增再删</p>
</blockquote>
<h2 id="13-root密码丢失找回"><a href="#13-root密码丢失找回" class="headerlink" title="13. root密码丢失找回"></a>13. root密码丢失找回</h2><blockquote>
<p>丢失时的密码重置</p>
</blockquote>
<pre><code>1、    停止服务
    pkill mysqld    
2、    重启服务，但需要跳过授权表限制
    /usr/local/mysql/bin/mysqld_safe --skip-grant-tables --user=mysql &amp;    
3、    登录
    mysql -uroot
    不用密码即可    
4、    查看现有用户
    select user,host,password from mysql.user;    
5、    修改密码
    update mysql.user set password=password(&apos;123&apos;) where user=&apos;root&apos; and host=&apos;localhost&apos;    
6、    退出
    exit    
7、    重启MySQL
    pkill mysqld
    /usr/local/mysql/bin/mysqld_safe --user=mysql &amp;
</code></pre><blockquote>
<p>正常修改密码方式：</p>
</blockquote>
<pre><code>方法一： 
正常登陆mysql后，
     set password for root@localhost=password(&quot;123&quot;);

方法二：
脚本命令行    
    ./mysqladmin -u root -p password mypasswd（新密码）
然后输入旧密码
</code></pre></the>]]></content>
      
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 常用操作 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL字符类型]]></title>
      <url>/2017/10/10/MySQL%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p><strong> MySQL字符类型：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>——–        字符类型<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<pre><code>1.整数类型
========
    整数类型    字节数   无符号范围                有符号的范围
    tinyint     1        0~255                     -128~127
    smalllint   2        0~65535                   -32768~32767
    mediumint   3        0~16777215                -8388608~8388607
    int         4        0~4294967295              -2147483648~2147483647
    bigint      8        0~18446744073709551615    -9223372036854775808~9223372036854775808

    mysql支持数据类型的后面指定该类型的显示宽度。其基本形式如下：
    格式: 数据类型(显示宽度)

    默认显示宽度：可以理解为，一个数据类型的默认显示宽度正好是能显示该数据类型的所有值的宽度。
              长度
    tinyint    4
    smallint   6
    mediumint  9
    int        11  无符号则10
    bigint     20

    tinyint(1)

    在整数类型使用时，可以搭配zerofill参数，zerofill参数表示数字不足的显示空间由0来填充。
    注意：使用zerofill时，mysql会自动加上unsigned属性。那么，该整数类型只能表示无符号数，其显示宽度比默认显示宽度小1。

    在设置了显示宽度时，如果插入的数据宽度大小设置的显示宽度时，数据依然可以插入，且能够显示。该设置的宽度失效。
    注意：数据的宽度不能大于默认宽度。如果大于默认宽度，那该数据已经超过了该类型的最大值。因为最大值的宽度必须是小于等于默认宽度。如果一个值大于最大值，将不可能插入。
    整数类型还有一个auto_increment属性。自增。

2.浮点数和定点数
==============
    mysql中使用浮点数和定点数来表示小数。
    浮点数：单精度浮点数(float)和双精度浮点数(double)。
    定义数：decimal

    浮点类型   字节数  负数的取值范围                                      非负数的取值范围
    float      4       -3.402823466e+38~-1.175494351e-38                   0和-1.175494351e-38~3.402823466e+38
    double     8       -1.79769313486223157e+308~-2.2250738585072014e-308  0和-2.2250738585072014e-308~1.79769313486223157e+308
    decimal    m+2     同double                                            同double

    定点数的存储空间是根据其精度来决定的。
    mysql中可以指定浮点数的精度： 

    格式: 数据类型(m,d)   decimal(10,2)

    m-精度，是数据的总长度，小数点占一个位置
    d-标度，小数点后的长度

    如果插入的值的精度高于实际定义的精度，系统会自动进行四舍五入处理。float double不会报错，decimal会报一个警告
    在存储小数时，建议使用decimal类型，定点数以字符串形式储存。因此，精度要比浮点数要高。而且，浮点数会出现误差，这是浮点数一直存在的缺陷。如果对数据的精度要求比较高，还是选择定点数(decimal)比较安全。
    decimal(m,d) 常用于 money 类字段

3.日期与时间类型
==============
    数据类型   字节数  取值范围                                 零值
    year       1       1901~2155                                0000
    date       4       1000-01-01~9999-12-31                    0000:00:00
    time       3       -838:59:59~838:59:59                     00:00:00
    datetime   8       1000-01-01 00:00:00~9999-12-31 23:59:59  0000-00-00 00:00:00
    timestamp  4       19700101080001~20380119111417            00000000000000

    year:
    超出范围就会插入0000
    使用2位字符串表示，&apos;00&apos;~&apos;69&apos;转换为2000~2069，&apos;70&apos;~&apos;99&apos;转换为1970~1999
    使用2位数字表示，00~69转换为2000~2069，70~99转换为1970~1999。
    注意两位的数字和两位的字符串是不一样的：0-0000 &apos;0&apos;&apos;00&apos;-2000

    date:
    4个字节来表示日期。以yyyy-mm-dd的形式来显示date类型的值。
    1）&apos;yyyy-mm-dd&apos;或&apos;yyyymmdd&apos;格式的字符串表示。
    2）mysql中还支持一些不严格的语法格式：&apos;yyyymmdd&apos; &apos;yyyy@mm@dd&apos; &apos;yyyy.mm.dd&apos;
    3)&apos;yy-mm-dd&apos;或&apos;yymmdd&apos;格式的字符串表示。
    4）yy取值同year类型中的两位字符串的表示一致。
    5）yyyymmdd或yymmdd格式的数字表示。yy取值同上。
    虽然mysql支持date类型的一些不严格的语法格式。但是，实际运用中，最好还是选择标准形式。日期中使用-做分隔符，时间用：做分隔符。如果有特殊需要也可以使用@、* 等特殊字符做分隔符。
    使用current_date和now()转换为当前系统日期。

4.字符串类型
==========
    字符串类型是mysql中用来存储字符串的数据类型。字符串类型包括char varchar blob text enum set。

    char 和 varchar 类型
    =================
    字符串类型(m) m-该字符串的最大长度为m
    char    定长字符类型 0~255
    varchar 变长字符类型 5.0版本以前0~255 5.0版本以后0~65535

    char(5)和varchar(5)的区别

    插入值   char占用字节数  varchar占用字节数
    &apos;&apos;       5               1
    &apos;1&apos;      5               2
    &apos;123&apos;    5               4
    &apos;1234&apos;   5               5
    &apos;12345&apos;  5               6

    如果插入值的长度大于m，则插入失败。

5.text类型
========
    类型       范围          占用空间
    tinytext   0~255         长度+2个字节
    text       0~65535       长度+2个字节
    mediumtext 0~167772150   长度+3个字节
    longtext   0~4294967295  长度+4个字节

6.enum类型
========
    又称枚举类型。
    enum(&apos;值1&apos;，&apos;值2&apos;，...，&apos;值n&apos;)
    n-代表参数列表中的第n个值，这些值末尾的空格会被系统直接删除。
    enum类型的值只能取列表中的一个元素。
    取值列表中最多能有65535成员。
    列表中的每一个值都有一个顺序排列的编号，mysql存入的是这个编号，而不是值。

7.set类型
=======
    在创建表时，set类型的取值范围就以列表的形式指定了。
    set(&apos;值1&apos;，&apos;值2&apos;，...，&apos;值n&apos;)
    set类型的值最多只以是有64个元素构成的组合。取值可以是其中的一个或多个。其它特性，与enum类似。

8.二进制类型
==========
    二进制类型是在数据库中存储二进制数据的数据类型。
    类型            取值范围
    binary(m)       字节数为m，允许长度为0~m的定长二进制字符串
    varbinary(m)    允许长度为0~m的变长二进制字符串，字节数为值的长度加1
    bit(m)          m位二进制数，m最大值为64
    tinyblob        可变长二进制数据，最多255个字节
    blob            可变长二进制数据，最多2e16-1个字节
    mediumblob      可变长二进制数据，最多2e24-1个字节
    longblob        可变长二进制数据，最多2e32-1个字节
</code></pre></the>]]></content>
      
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 字符类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL基础]]></title>
      <url>/2017/10/10/MySQL%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p><strong> MySQL基础：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>——–        基础操作<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">


<h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code>1、设置密码
    set password = password();
2、创建数据库
    create database [if not exists] dbName;
3、查看所有数据库
    show database;
4、删除数据库
    drop database dbName;
5、使用数据库
    use database dbName;
6、查看所有的表
    show tables;
7、删除数据表
    drop table tabName;
8、创建数据表
    create table if not exists tabName(
        字段名 字段类型 字段属性，
        字段名 字段类型 字段属性，
        字段名 字段类型 字段属性
    ) engine = engName  default charset = utf8;

9、增加数据
    insert into tabName(字段名) values(v1),(v2)...   插入所有字段时，可以不写字段名
10、更新
    update tabName set 字段名 = 值 ； 全表修改
    updata tabName set 字段名 = 值 where...
11、删除
    delete from tabName; 全部表
    delete from tabName where ...
12、查看
    select * from tabName ; 全部
    select k1,k2.. from tabName where .. group by.. order by .. limit..
13、修改表名 
    alter table oldName rename newName;
14、修改字段的数据类型
    alter table tabName modify 字段名 新数据类型
    alter table tabName modify 字段名 新数据类型 before/after 指定字段名
15、修改字段名
    alter table tabName change old new [新数据类型]
16、增加字段
    alter table tabName add 字段名 数据类型 [before/after 字段名]
17、删除字段
    alter table tabName drop 字段名
18、更改表的引擎
    alter table tabName  engine = NEW 
19、修改数据库的字符集
    alter database dbName character set NEW;
20、更改数据表的字符集
    alter table tabName convert to character set NEW;
21、查看存储引擎
    show create table tabName;
</code></pre><h4 id="MySQL运算符"><a href="#MySQL运算符" class="headerlink" title="MySQL运算符"></a>MySQL运算符</h4><pre><code>1. 算术运算符
        +      -       *      /         DIV      %       MOD
2. 比较运算符
    数据列类型            说明                                        取值范围
    =                    a=b                                    若操作数a与操作数b相等，则为真
    &lt;=&gt;                    a&lt;=&gt;b                                若a与b相等，则为真，可以用于NULL值比较
    !=或&lt;&gt;                a!=b或a&lt;&gt;b                            若操作数a与b不相等，为真
    &lt;                    a&lt;b                                    若操作数a小于b，为真
    &lt;=                    a&lt;=b                                若操作数a大于b，为真
    &gt;                    a&gt;b                                    若操作数a大于b，为真
    &gt;=                    a&gt;=b                                若操作数a大于等于b，为真
    IS NULL                a IS NULL                            若操作数a为NULL，为真
    IS NOT NULL            a IS NOT NULL                        若操作数a不为NULL，为真
    BETWEEN                a BETWEEN b AND c                    若a在b和c之间，为真
    NOT BETWEEN            a NOT BETWEEN b AND c                若操作数a不在b和c之间，为真
    LIKE                a LIKE b                            SQL模式匹配，若a匹配b，为真
    NOT LIKE            a NOT LIKE b                        SQL模式匹配，若a不匹配b，则为真
    IN                    a IN (b1,b2….)                        若a等于b1,b2,b3,…中的某一个，则为真
3. 逻辑运算符
    操作符                语法                                        描述
    AND 或 &amp;&amp;            a AND b 或 a &amp;&amp; b                    逻辑与，若两个操作数同时为真，则为真
    OR 或 ||                a OR b 或 a||b                        逻辑或，只要有一个操作数为真，则为真

    XOR                    a XOR b                                 逻辑异或，若有且仅有一个操作数为真，则为真
            一真一假即为真, 同真同假即为假

    NOT 或 ！            NOT a 或 ！a                        逻辑非，若操作数为假，则为真
</code></pre></the>]]></content>
      
        
        <tags>
            
            <tag> 基本操作 </tag>
            
            <tag> MYSQL </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
